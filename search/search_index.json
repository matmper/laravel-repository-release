{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Laravel Repository Release - v1.x Github: matmper/laravel-repository-release Use the package to add a layer between modeling and services. Install Install this package with Composer: $ composer require matmper/laravel-repository-release Use the command below to publish the package and generate the /config/repository.php file: $ php artisan vendor:publish --provider=\"Matmper\\Providers\\RepositoryProvider\"","title":"Home"},{"location":"#laravel-repository-release-v1x","text":"Github: matmper/laravel-repository-release Use the package to add a layer between modeling and services.","title":"Laravel Repository Release - v1.x"},{"location":"#install","text":"Install this package with Composer: $ composer require matmper/laravel-repository-release Use the command below to publish the package and generate the /config/repository.php file: $ php artisan vendor:publish --provider=\"Matmper\\Providers\\RepositoryProvider\"","title":"Install"},{"location":"configuration/","text":"Configuration The configuration file is generated during package publishing: $ php artisan vendor:publish --provider=\"Matmper\\Providers\\RepositoryProvider\" The command will generate the config/repository.php file with default settings <?php # config/repository.php 'default' => [ // default limit of results per page 'paginate' => env('REPOSITORY_DEFAULT_PAGINATE', 25), // true = forces the use of the withTrashed() method by default 'with_trashed' => env('REPOSITORY_WITH_TRASHED', false), ],","title":"Configuration"},{"location":"configuration/#configuration","text":"The configuration file is generated during package publishing: $ php artisan vendor:publish --provider=\"Matmper\\Providers\\RepositoryProvider\" The command will generate the config/repository.php file with default settings <?php # config/repository.php 'default' => [ // default limit of results per page 'paginate' => env('REPOSITORY_DEFAULT_PAGINATE', 25), // true = forces the use of the withTrashed() method by default 'with_trashed' => env('REPOSITORY_WITH_TRASHED', false), ],","title":"Configuration"},{"location":"quick-start/","text":"Quick Start In the quick guide we will exemplify the use of a User Model repository! Create new repository Run the command below to generate the app/Repositories/UserRepository.php file: $ php artisan repository:create User An alternative is to generate all pending repositories: $ php artisan repository:create all This is an example of the generated UserRepository.php file. namespace App\\Repositories; use Matmper\\Repositories\\BaseRepository; final class UserRepository extends BaseRepository { /** * @var \\App\\Models\\User; */ protected $model; public function __construct() { $this->model = new \\App\\Models\\User(); parent::__construct(); } } Simplified use User Repository is ready to use. Instantiate the package in the desired service and call the desired method. use \\App\\Repositories\\UserRepository; public function __construct(private UserRepository $userRepository) { // } public function show(int $id): Model { return $this->userRepository->findOrFail($id, ['id', 'name']); }","title":"Quick Start"},{"location":"quick-start/#quick-start","text":"In the quick guide we will exemplify the use of a User Model repository!","title":"Quick Start"},{"location":"quick-start/#create-new-repository","text":"Run the command below to generate the app/Repositories/UserRepository.php file: $ php artisan repository:create User An alternative is to generate all pending repositories: $ php artisan repository:create all This is an example of the generated UserRepository.php file. namespace App\\Repositories; use Matmper\\Repositories\\BaseRepository; final class UserRepository extends BaseRepository { /** * @var \\App\\Models\\User; */ protected $model; public function __construct() { $this->model = new \\App\\Models\\User(); parent::__construct(); } }","title":"Create new repository"},{"location":"quick-start/#simplified-use","text":"User Repository is ready to use. Instantiate the package in the desired service and call the desired method. use \\App\\Repositories\\UserRepository; public function __construct(private UserRepository $userRepository) { // } public function show(int $id): Model { return $this->userRepository->findOrFail($id, ['id', 'name']); }","title":"Simplified use"},{"location":"usage/","text":"Usage Instantiate the package in the desired service and call the desired method. Load class with constructor property: use \\App\\Repositories\\UserRepository; public function __construct(private UserRepository $userRepository) { // } As above, the repository will be stored in $this->userRepository , but it is also possible to load and use individually: $userRepository = new \\App\\Repositories\\UserRepository; $user = $userRepository->findOrFail(1); Query methods /** * Get a model collection * @return Collection */ public function index(): Collection { return $this->userRepository->get( [ 'role' => 'user', // users.role = 'user' 'name LIKE' => \"%A%\", // && users.name LIKE \"%A%\" 'id NOT IN' => [1,2,3], // && users.id NOT IN (1,2,3) 'created_at >=' => date('Y-m-d'), // && users.created >= now() ], ['id', 'name'], // select columns names ['name' => 'ASC', 'id' => 'DESC'] // order by ); } /** * Get a single line from the database * @return \\Illuminate\\Database\\Eloquent\\Model */ public function show(int $id): Model { // $this->userRepository->find($id); // $this->userRepository->first(['id' => $id]); // $this->userRepository->firstOrFail(['id' => $id]); return $this->userRepository->findOrFail($id, ['id', 'name']); } /** * Store a new database row * @return \\Illuminate\\Database\\Eloquent\\Model */ public function store($request): Model { return $this->userRepository->create([ 'name' => $request->name, ]); } /** * Update a database row by primary key * @return \\Illuminate\\Database\\Eloquent\\Model */ public function update(int $id, $request): Model { // $user = $this->userRepository->findOrFail($id, ['*']); // return $this->userRepository->updateCollection($user, ['name' => ...]); return $this->userRepository->update($id, [ 'name' => $request->name, ]); } /** * Delete a database row * @return boolean */ public function delete(int $id): bool { // $this->userRepository->forceDelete($id); return $this->userRepository->delete($id); } /** * Restores data by clearing the soft delete field * @return boolean */ public function restore(int $id): bool { return $this->userRepository->restore($id); // Necessary SoftDelete } Trashed Methods Capture deleted or not deleted data: Models with soft delete can use the withTrashed and withoutTrashed methods. /** * Return all users even with the soft deleted field populated * @return \\Illuminate\\Database\\Eloquent\\Model */ public function index(int $id): Model { return $this->userRepository->withTrash()->get(); } /** * Returns the user if soft deleted column is null * @return \\Illuminate\\Database\\Eloquent\\Model */ public function show(int $id): Model { return $this->userRepository->withouTrash()->findOrFail($id); }","title":"Usage"},{"location":"usage/#usage","text":"Instantiate the package in the desired service and call the desired method. Load class with constructor property: use \\App\\Repositories\\UserRepository; public function __construct(private UserRepository $userRepository) { // } As above, the repository will be stored in $this->userRepository , but it is also possible to load and use individually: $userRepository = new \\App\\Repositories\\UserRepository; $user = $userRepository->findOrFail(1);","title":"Usage"},{"location":"usage/#query-methods","text":"/** * Get a model collection * @return Collection */ public function index(): Collection { return $this->userRepository->get( [ 'role' => 'user', // users.role = 'user' 'name LIKE' => \"%A%\", // && users.name LIKE \"%A%\" 'id NOT IN' => [1,2,3], // && users.id NOT IN (1,2,3) 'created_at >=' => date('Y-m-d'), // && users.created >= now() ], ['id', 'name'], // select columns names ['name' => 'ASC', 'id' => 'DESC'] // order by ); } /** * Get a single line from the database * @return \\Illuminate\\Database\\Eloquent\\Model */ public function show(int $id): Model { // $this->userRepository->find($id); // $this->userRepository->first(['id' => $id]); // $this->userRepository->firstOrFail(['id' => $id]); return $this->userRepository->findOrFail($id, ['id', 'name']); } /** * Store a new database row * @return \\Illuminate\\Database\\Eloquent\\Model */ public function store($request): Model { return $this->userRepository->create([ 'name' => $request->name, ]); } /** * Update a database row by primary key * @return \\Illuminate\\Database\\Eloquent\\Model */ public function update(int $id, $request): Model { // $user = $this->userRepository->findOrFail($id, ['*']); // return $this->userRepository->updateCollection($user, ['name' => ...]); return $this->userRepository->update($id, [ 'name' => $request->name, ]); } /** * Delete a database row * @return boolean */ public function delete(int $id): bool { // $this->userRepository->forceDelete($id); return $this->userRepository->delete($id); } /** * Restores data by clearing the soft delete field * @return boolean */ public function restore(int $id): bool { return $this->userRepository->restore($id); // Necessary SoftDelete }","title":"Query methods"},{"location":"usage/#trashed-methods","text":"Capture deleted or not deleted data: Models with soft delete can use the withTrashed and withoutTrashed methods. /** * Return all users even with the soft deleted field populated * @return \\Illuminate\\Database\\Eloquent\\Model */ public function index(int $id): Model { return $this->userRepository->withTrash()->get(); } /** * Returns the user if soft deleted column is null * @return \\Illuminate\\Database\\Eloquent\\Model */ public function show(int $id): Model { return $this->userRepository->withouTrash()->findOrFail($id); }","title":"Trashed Methods"}]}